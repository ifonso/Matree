//
//  Lexer.swift
//
//
//  Created by Afonso Lucas on 21/02/24.
//

import Foundation


enum TokenizationError: Error {
    case invalidExpression
    case invalidDigit
    case unclosedBracket
    case invalidOperatorPosition
}

/// Used to define the type of a token for use in tree structure.
enum TokenType {
    case `operator`
    case number
    
    case rightBracket
    case leftBracket
}

/// Struct representing a token generated by the lexer for use in creating tree nodes.
struct Token {
    
    let value: String
    let type: TokenType
}

/// Class responsible for tokenizing mathematical expressions.
final class Lexer {
    
    private var expression: String = ""
    private var openBrackets: Int = 0
    private var currentToken: String = ""
    
    private var tokens: [Token] = []
    
    private var length: Int {
        self.expression.count
    }
    
    /// Tokenizes the given expression and returns an array of tokens.
    /// - Parameter expression: The expression to tokenize.
    /// - Returns: An array of tokens representing the expression.
    func getTokens(expression: String) throws -> [Token] {
        // Reset state
        self.expression = expression
        self.openBrackets = 0
        self.currentToken = ""
        self.tokens = []
        // Basic Validation
        guard isValidExpression(expression) else {
            throw TokenizationError.invalidExpression
        }
        // Tokenize
        try tokenize()
        return tokens
    }
    
    private func tokenize() throws {
        for (i, c) in expression.enumerated() {
            try self.createToken(char: c, index: i)
        }
        
        guard openBrackets == 0 else {
            throw TokenizationError.unclosedBracket
        }
    }
    
    private func createToken(char: Character, index: Int) throws {
        if isInDigit(char) {
            // invalid cases of .
            if char == "." {
                // invalidate: .01283 -.
                if currentToken.isEmpty || (currentToken.count == 1 && currentToken.first == "-") {
                    throw TokenizationError.invalidDigit
                }
                // invalidate: 1.
                guard let next = expression[safe: index + 1] else {
                    throw TokenizationError.invalidDigit
                }
                // invalidate: 1.+
                guard isInDigit(next) && next != "." else {
                    throw TokenizationError.invalidDigit
                }
            }
            
            // invalidate: 01
            if char == "0" && currentToken.isEmpty {
                throw TokenizationError.invalidDigit
            }
            
            currentToken.append(char)
            
            if index == length - 1 {
                tokens.append(Token(value: currentToken, type: .number))
                currentToken = ""
            }
            
        } else if !currentToken.isEmpty {
            tokens.append(Token(value: currentToken, type: .number))
            currentToken = ""
        }
        
        if isOperator(char) {
            // Operators shall not be at the end
            guard let next = expression[safe: index + 1] else {
                throw TokenizationError.invalidOperatorPosition
            }
            
            // invalidate: -+
            guard isInDigit(next) || next == "-" || isBracket(next) else {
                throw TokenizationError.invalidOperatorPosition
            }
            
            // Invalid uses of -
            if char == "-" {
                // soleve bug ---
                if let anteprev = expression[safe: index - 2] {
                    guard anteprev != "-" else {
                        throw TokenizationError.invalidOperatorPosition
                    }
                }
                // adding to expression
                if let prev = expression[safe: index - 1] {
                    if isOperator(prev) {
                        guard currentToken.isEmpty else {
                            throw TokenizationError.invalidOperatorPosition
                        }
                        currentToken.append(char)
                        return
                    }
                }
            // Invalid uses of + / *
            } else {
                // invalidate: *12
                guard let prev = expression[safe: index - 1] else {
                    throw TokenizationError.invalidOperatorPosition
                }
                // invalidate: */
                guard isInDigit(prev) || isBracket(prev) else {
                    throw TokenizationError.invalidOperatorPosition
                }
            }
            
            tokens.append(Token(value: String(char), type: .operator))
        }
        // Dealing with brackets
        else {
            if char == "(" {
                tokens.append(
                    Token(value: "(", type: .leftBracket)
                )
                openBrackets += 1
            } else if char == ")" {
                tokens.append(
                    Token(value: ")", type: .rightBracket)
                )
                openBrackets -= 1
            }
        }
    }
    
    // MARK: - Utility
    
    private func isValidExpression(_ input: String) -> Bool {
        return input.rangeOfCharacter(
            from: CharacterSet(charactersIn: "0123456789.-+*/()").inverted
        ) == nil
    }
    
    private func isOperator(_ v: Character) -> Bool {
        "+-*/".contains(v)
    }
    
    private func isInDigit(_ v: Character) -> Bool {
        "0123456789.".contains(v)
    }
    
    private func isBracket(_ v: Character) -> Bool {
        "()".contains(v)
    }
}
